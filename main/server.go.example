/*
Copyright 2024 Eduardo Lezcano √Ålvarez
*/

package main

import (
    "encoding/json"
    "log"
    "net/http"
    "strconv"
    "sync"
)

type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
    Age  int    `json:"age"`
}

type Users struct {
    sync.Mutex
    Data map[int]User
}

func NewUsers() *Users {
    return &Users{
        Data: make(map[int]User),
    }
}

func (us *Users) Add(user User) {
    us.Lock()
    defer us.Unlock()
    us.Data[user.ID] = user
}

func (us *Users) Get(userID int) (User, bool) {
    us.Lock()
    defer us.Unlock()
    user, ok := us.Data[userID]
    return user, ok
}

func handleGetUsers(w http.ResponseWriter, r *http.Request) {
    us.Lock()
    defer us.Unlock()
    var users []User
    for _, user := range us.Data {
        users = append(users, user)
    }
    json.NewEncoder(w).Encode(users)
}

func handleGetUser(w http.ResponseWriter, r *http.Request) {
    userID, err := strconv.Atoi(r.URL.Path[len("/users/"):])
    if err != nil {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        return
    }

    user, ok := us.Get(userID)
    if !ok {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }

    json.NewEncoder(w).Encode(user)
}

func handleAddUser(w http.ResponseWriter, r *http.Request) {
    var newUser User
    if err := json.NewDecoder(r.Body).Decode(&newUser); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    us.Add(newUser)

    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newUser)
}

var us = NewUsers()

func main() {
    http.HandleFunc("/users", handleGetUsers)
    http.HandleFunc("/users/", handleGetUser)
    http.HandleFunc("/add-user", handleAddUser)

    log.Fatal(http.ListenAndServe(":8080", nil))
}
